# -*- coding: utf-8 -*-
"""dicom_vol.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IWC-33BLlXERjh5f2gXd2WQPX3GBMEHQ
"""

pip install pydicom

import pydicom as pdc
import os

def get_header_and_images(ds):
    """
    Method to get b scan images and corresponding header information
    :param ds: dicom data sequence
    :return: header and images
    """

    # info regarding pixel spacing and eye
    sub_field_spacing_eye = ds.get('SharedFunctionalGroupsSequence', [])

    # Check if the required tags are present, otherwise provide default values
    if sub_field_spacing_eye:
        pix_spacing = sub_field_spacing_eye[0].get((0x0028, 0x9110), [])
        if pix_spacing:
            pixels_dist = pix_spacing[0].get((0x0028, 0x0030), {}).value
            dist = pix_spacing[0].get((0x0018, 0x0050), {}).value
        else:
            pixels_dist = [1, 1]
            dist = 1.0
        eye_info = sub_field_spacing_eye[0].get((0x0020, 0x9071), [])
        if eye_info:
            eye_side = str(eye_info[0].get((0x0020, 0x9072), {}).value)
            if eye_side == 'L':
                eye_side = 'OS'
            else:
                eye_side = 'OD'
        else:
            eye_side = ''
    else:
        pixels_dist = [1, 1]
        dist = 1.0
        eye_side = ''

    header = {'Version': ds.get((0x0008, 0x1090), {}).value,
              'SizeX': ds.get((0x0028, 0x0011), {}).value,
              'NumBScans': ds.get((0x0028, 0x0008), {}).value,
              'SizeZ': ds.get((0x0028, 0x0010), {}).value,
              'ScaleX': pixels_dist[1],
              'Distance': dist,
              'ScaleZ': pixels_dist[0],
              'ScanFocus': '',
              'ScanPosition': eye_side,
              'ExamTime': ds.StudyDate,
              'ScanPattern': '',
              'BScanHdrSize': '',
              'ID': ds.get((0x0020, 0x0010), {}).value,
              'ReferenceID': ds.get((0x0020, 0x0011), {}).value,
              'PID': '',
              'PatientID': ds.get((0x0010, 0x0020), {}).value,
              'Padding': '',
              'DOB': ds.get((0x0010, 0x0030), {}).value,
              'VID': '',
              'VisitID': '',
              'VisitDate': '',
              'GridType': '',
              'GridOffset': '',
              'GridType1': '',
              'GridOffset1': '',
              'ProgID': '',
              'PatientSex': ds.get((0x0010, 0x0040), {}).value,
              'DeviceManufacturer': ds.get((0x0008, 0x0070), {}).value,
              'EmmetropicMagnification': ds.get((0x0022, 0x000a), {}).value,
              'IOP': ds.get((0x0022, 0x000b), {}).value,
              'HorizontalFieldofView': ds.get((0x0022, 0x000c), {}).value,
              'PupilDilated': ds.get((0x0022, 0x000d), {}).value,
              'AxialLength': ds.get((0x0022, 0x0030), {}).value,
              'DepthSpatialResolution': ds.get((0x0022, 0x0035), {}).value}

    images = ds.pixel_array
    return header, images


def get_slo(data_seq_slo):
    """
    Method to get slo information including slo image and header
    :param data_seq_slo: dicom data sequence
    :return: header and slo image
    """

    header_slo = {
              'SizeXSlo': data_seq_slo.Columns,
              'SizeYSlo': data_seq_slo.Rows,
              'ScaleXSlo': data_seq_slo.PixelSpacing[0],
              'ScaleYSlo': data_seq_slo.PixelSpacing[1],
              'FieldSizeSlo': data_seq_slo[0x0022, 0x000c].value}
    slo_image = data_seq_slo.pixel_array
    return header_slo, slo_image


def main_read_dcm_spectralis(dicom_file_name, slo_file_name):
    header_slo = {}
    slo_image = []
    warning = 0

    # Assuming the DICOM and SLO files are already uploaded in the current Colab environment

    # Read the SLO file
    slo_file_path = slo_file_name  # Assuming slo_file_name is in the same directory as the DICOM file
    if os.path.exists(slo_file_path):
        d_seq_slo = pdc.dcmread(slo_file_path)
        header_slo, slo_image = get_slo(d_seq_slo)
    else:
        warning = 2003

    # Read the DICOM file
    d_seq = pdc.dcmread(dicom_file_name)

    header, b_scans = get_header_and_images(d_seq)
    header = {**header, **header_slo}
    return warning, header, b_scans, slo_image

# Example usage:
dicom_file_name = "/content/drive/MyDrive/Nocturne/00000011.dcm"  # Replace with your DICOM file name
slo_file_name = "/content/drive/MyDrive/Nocturne/00000010.dcm"    # Replace with your SLO file name

warning, header, b_scans, slo_image = main_read_dcm_spectralis(dicom_file_name, slo_file_name)
print("Warning:", warning)
print("Header:", header)
print("B Scans Shape:", b_scans.shape if b_scans is not None else "No B Scans")
print("SLO Image Shape:", slo_image.shape if slo_image is not None else "No SLO Image")

import pydicom
import numpy as np

def convert_dicom_and_slo_to_vol(dicom_file_path, slo_file_path, vol_file_path):
    # Read DICOM file
    dicom_data = pydicom.dcmread(dicom_file_path)

    # Read SLO file
    slo_data = pydicom.dcmread(slo_file_path)

    # Create a header dictionary with relevant DICOM and SLO tags
    header = {
        'Version': 'YourVersion',
        'SizeX': getattr(dicom_data, 'Columns', 0),
        'NumBScans': getattr(dicom_data, 'NumberOfFrames', 0),
        'SizeZ': getattr(dicom_data, 'Rows', 0),
        'ScaleX': getattr(dicom_data, 'PixelSpacing', [1, 1])[1] if hasattr(dicom_data, 'PixelSpacing') else 1,
        'Distance': getattr(dicom_data, 'PixelSpacing', [1, 1])[0] if hasattr(dicom_data, 'PixelSpacing') else 1,
        'ScaleZ': 1.0,  # You may need to adjust this based on your data
        'ScanFocus': '',
        'ScanPosition': 'OS',  # Adjust as needed
        'ExamTime': getattr(dicom_data, 'StudyDate', ''),  # You may need to adjust this based on your data
        'SizeXSlo': getattr(slo_data, 'Columns', 0),
        'SizeYSlo': getattr(slo_data, 'Rows', 0),
        'ScaleXSlo': getattr(slo_data, 'PixelSpacing', [1, 1])[0] if hasattr(slo_data, 'PixelSpacing') else 1,
        'ScaleYSlo': getattr(slo_data, 'PixelSpacing', [1, 1])[1] if hasattr(slo_data, 'PixelSpacing') else 1,
        'FieldSizeSlo': getattr(slo_data, 'FieldSizeSlo', 0),  # Adjust the tag accordingly
        # Add more header fields as needed
    }

    # Save header to VOL file
    with open(vol_file_path, 'w') as vol_file:
        # Write header data
        for key, value in header.items():
            vol_file.write(f"{key}: {value}\n")

    # Extract image data
    b_scans = np.stack([dicom_data.pixel_array] * getattr(dicom_data, 'NumberOfFrames', 0), axis=-1)
    slo_image = slo_data.pixel_array

    # Save image data to VOL file (you may need to adjust this based on the VOL file format)
    with open(vol_file_path, 'ab') as vol_file:
        b_scans.tofile(vol_file)
        slo_image.tofile(vol_file)

# Example usage
dicom_file_path = '/content/drive/MyDrive/Nocturne/00000011.dcm'
slo_file_path = '/content/drive/MyDrive/Nocturne/00000010.dcm'
vol_file_path = '/content/drive/MyDrive/Nocturne/dcm_vol.vol'

convert_dicom_and_slo_to_vol(dicom_file_path, slo_file_path, vol_file_path)

import pydicom
import numpy as np
import datetime

class DICOMtoVOLConverter:
    def __init__(self, dicom_path, output_vol_path):
        self.dicom_path = dicom_path
        self.output_vol_path = output_vol_path

    def convert_to_vol(self):
        with open(self.dicom_path, 'rb') as dicom_file:
            dicom_dataset = pydicom.dcmread(dicom_file)

            # Extract relevant information from DICOM header
            size_x = dicom_dataset.Rows
            num_b_scans = dicom_dataset.NumberOfFrames
            size_z = dicom_dataset.Columns
            scale_x = dicom_dataset.PixelSpacing[0] if "PixelSpacing" in dicom_dataset else 1.0
            distance = dicom_dataset.SliceThickness if "SliceThickness" in dicom_dataset else 1.0
            scale_z = dicom_dataset.PixelSpacing[1] if "PixelSpacing" in dicom_dataset else 1.0

            # Create a header dictionary
            header = {
                'version': 'DICOMtoVOL',
                'size_x': size_x,
                'num_b_scans': num_b_scans,
                'size_z': size_z,
                'scale_x': scale_x,
                'distance': distance,
                'scale_z': scale_z,
                'size_x_slo': 0,  # Modify as needed
                'size_y_slo': 0,  # Modify as needed
                'scale_x_slo': 0.0,  # Modify as needed
                'scale_y_slo': 0.0,  # Modify as needed
                'field_size_slo': 0,  # Modify as needed
                'scan_focus': 0.0,  # Modify as needed
                'scan_position': '',  # Modify as needed
#                'unconverted_exam_time': int((dicom_dataset.StudyDate + dicom_dataset.StudyTime).strftime('%Y%m%d%H%M%S%f')),
                'scan_pattern': 0,  # Modify as needed
                'b_scan_hdr_size': 0,  # Modify as needed
                'id': '',  # Modify as needed
                'reference_id': '',  # Modify as needed
                'pid': 0,  # Modify as needed
                'patient_id': '',  # Modify as needed
                'padding': np.zeros(3, dtype='int8'),  # Modify as needed
                'unconverted_dob': 0.0,  # Modify as needed
                'vid': 0,  # Modify as needed
                'visit_id': '',  # Modify as needed
                'unconverted_visit_date': 0.0,  # Modify as needed
                'grid_type': 0,  # Modify as needed
                'grid_offset': 0,  # Modify as needed
                'spare': np.zeros(1832, dtype='int8')  # Modify as needed
            }

            # Create an empty SLO array
            slo = np.zeros((header['size_y_slo'], header['size_x_slo']), dtype='uint8')

            # Create empty B-scan header and B-scans
            b_scan_header = {
                'version': np.full((12, header['num_b_scans']), "\0", dtype='U'),
                'b_scan_hdr_size': np.full(header['num_b_scans'], 0, dtype='int32'),
                'start_x': np.full(header['num_b_scans'], 0.0, dtype='float64'),
                'start_y': np.full(header['num_b_scans'], 0.0, dtype='float64'),
                'end_x': np.full(header['num_b_scans'], 0.0, dtype='float64'),
                'end_y': np.full(header['num_b_scans'], 0.0, dtype='float64'),
                'num_seg': np.full(header['num_b_scans'], 0, dtype='int32'),
                'off_seg': np.full(header['num_b_scans'], 0, dtype='int32'),
                'quality': np.full(header['num_b_scans'], 0.0, dtype='float32'),
                'shift': np.full(header['num_b_scans'], 0, dtype='int32'),
                'spare': np.full((192, header['num_b_scans']), 0, dtype='int8')
            }

            b_scans = np.full((header['size_z'], header['size_x'], header['num_b_scans']), 0.0, dtype='float32')

            # Create an empty thickness grid
            thickness_grid = {}

            # Save the OCTVol object to a VOL file
            with open(self.output_vol_path, 'wb') as vol_file:
                vol_file.write(header['version'].encode() + (12 - len(header['version'])) * b'\0')
                np.array(header['size_x'], dtype='int32').tofile(vol_file)
                np.array(header['num_b_scans'], dtype='int32').tofile(vol_file)
                np.array(header['size_z'], dtype='int32').tofile(vol_file)
                np.array(header['scale_x'], dtype='float64').tofile(vol_file)
                np.array(header['distance'], dtype='float64').tofile(vol_file)
                np.array(header['scale_z'], dtype='float64').tofile(vol_file)
                np.array(header['size_x_slo'], dtype='int32').tofile(vol_file)
                np.array(header['size_y_slo'], dtype='int32').tofile(vol_file)
                np.array(header['scale_x_slo'], dtype='float64').tofile(vol_file)
                np.array(header['scale_y_slo'], dtype='float64').tofile(vol_file)
                np.array(header['field_size_slo'], dtype='int32').tofile(vol_file)
                np.array(header['scan_focus'], dtype='float64').tofile(vol_file)
                vol_file.write(header['scan_position'].encode() + (4 - len(header['scan_position'])) * b'\0')
#                np.array(header['unconverted_exam_time'], dtype='int64').tofile(vol_file)
                np.array(header['scan_pattern'], dtype='int32').tofile(vol_file)
                np.array(header['b_scan_hdr_size'], dtype='int32').tofile(vol_file)
                vol_file.write(header['id'].encode() + (16 - len(header['id'])) * b'\0')
                vol_file.write(header['reference_id'].encode() + (16 - len(header['reference_id'])) * b'\0')
                np.array(header['pid'], dtype='int32').tofile(vol_file)
                vol_file.write(header['patient_id'].encode() + (21 - len(header['patient_id'])) * b'\0')
                header['padding'].tofile(vol_file)
                np.array(header['unconverted_dob'], dtype='float64').tofile(vol_file)
                np.array(header['vid'], dtype='int32').tofile(vol_file)
                vol_file.write(header['visit_id'].encode() + (24 - len(header['visit_id'])) * b'\0')
                np.array(header['unconverted_visit_date'], dtype='float64').tofile(vol_file)
                np.array(header['grid_type'], dtype='int32').tofile(vol_file)
                np.array(header['grid_offset'], dtype='int32').tofile(vol_file)
                header['spare'].tofile(vol_file)

                # Write the SLO image
                vol_file.seek(2048)
                slo.reshape(-1).tofile(vol_file)

                # Write BScan and BScan header
                for i_b_scan in range(header['num_b_scans']):
                    vol_file.seek(2048 + header['size_x_slo'] * header['size_y_slo'] +
                                  i_b_scan * (header['b_scan_hdr_size'] + header['size_x'] * header['size_z'] * 4))
                    np.vectorize(str.encode)(b_scan_header['version'][:, i_b_scan]).tofile(vol_file)
                    np.array(b_scan_header['b_scan_hdr_size'][i_b_scan], dtype='int32').tofile(vol_file)
                    np.array(b_scan_header['start_x'][i_b_scan], dtype='float64').tofile(vol_file)
                    np.array(b_scan_header['start_y'][i_b_scan], dtype='float64').tofile(vol_file)
                    np.array(b_scan_header['end_x'][i_b_scan], dtype='float64').tofile(vol_file)
                    np.array(b_scan_header['end_y'][i_b_scan], dtype='float64').tofile(vol_file)
                    np.array(b_scan_header['num_seg'][i_b_scan], dtype='int32').tofile(vol_file)
                    np.array(b_scan_header['off_seg'][i_b_scan], dtype='int32').tofile(vol_file)
                    np.array(b_scan_header['quality'][i_b_scan], dtype='float32').tofile(vol_file)
                    np.array(b_scan_header['shift'][i_b_scan], dtype='int32').tofile(vol_file)
                    b_scan_header['spare'][:, i_b_scan].tofile(vol_file)
                    vol_file.seek(2048 + header['size_x_slo'] * header['size_y_slo'] +
                                  i_b_scan * (header['b_scan_hdr_size'] + header['size_x'] * header['size_z'] * 4) +
                                  b_scan_header['off_seg'][i_b_scan])
                    for i_boundary in range(b_scan_header['num_seg'][i_b_scan]):
                        b_scan_header['boundary_{}'.format(i_boundary+1)][i_b_scan, :].tofile(vol_file)
                    vol_file.seek(2048 + header['size_x_slo'] * header['size_y_slo'] +
                                  i_b_scan * (header['b_scan_hdr_size'] + header['size_x'] * header['size_z'] * 4) +
                                  header['b_scan_hdr_size'])
                    b_scans[:, :, i_b_scan].reshape(-1).tofile(vol_file)

                # Write the thickness grid if it exists
                vol_file.seek(header['grid_offset'])
                if header['grid_type'] != 0:
                    np.array(thickness_grid['type'], dtype='int32').tofile(vol_file)
                    np.array(thickness_grid['diameter'], dtype='float64').tofile(vol_file)
                    np.array(thickness_grid['center_pos'], dtype='float64').tofile(vol_file)
                    np.array(thickness_grid['central_thk'], dtype='float64').tofile(vol_file)
                    np.array(thickness_grid['min_central_thk'], dtype='float64').tofile(vol_file)
                    np.array(thickness_grid['max_central_thk'], dtype='float64').tofile(vol_file)
                    np.array(thickness_grid['total_volume'], dtype='float64').tofile(vol_file)
                    for i_sector in range(9):
                        np.array(thickness_grid['sector_{}'.format(i_sector+1)]['thickness'], dtype='float64').tofile(vol_file)
                        np.array(thickness_grid['sector_{}'.format(i_sector+1)]['volume'], dtype='float64').tofile(vol_file)

# Example usage:
dicom_path = '/content/drive/MyDrive/Nocturne/00000011.dcm'
output_vol_path = '/content/drive/MyDrive/Nocturne/dcm_vol.vol'

converter = DICOMtoVOLConverter(dicom_path, output_vol_path)
converter.convert_to_vol()